#!/bin/bash

# Bunnify Server Startup Script

# Function to display help
show_help() {
    cat << EOF
üê∞ Bunnify - Smart Bookmark Manager

USAGE:
    ./start [OPTIONS]

DESCRIPTION:
    Starts the Bunnify Django development server with file watching for
    automatic bookmark reloading. The server runs on port 8000, accessible via:
    - http://127.0.0.1:8000 (IPv4)
    - http://[::1]:8000 (IPv6)
    - http://localhost:8000 (both)
    
    The server daemonizes itself and runs in the background. Startup messages
    including PIDs are displayed, but subsequent server output goes to the log
    file only (unless --console is specified).

OPTIONS:
    -h, --help
        Display this help message and exit

    -f, --bookmarks FILE
        Path to the bookmarks JSON file
        Default: ~/work/bunnify/bunnify.json

    --console
        Enable console logging in addition to file logging
        Default: disabled (logs only to file)

    --log-level LEVEL
        Set the logging level. Valid levels are:
            DEBUG    - Detailed diagnostic information
            INFO     - General informational messages
            WARNING  - Warning messages (default)
            ERROR    - Error messages only
            CRITICAL - Critical errors only
        Default: WARNING

EXAMPLES:
    # Start with default settings (WARNING level, file logging only)
    ./start

    # Start with custom bookmarks file
    ./start -f /path/to/my-bookmarks.json
    ./start --bookmarks ~/custom/bookmarks.json

    # Start with console output enabled
    ./start --console

    # Start with DEBUG level logging
    ./start --log-level DEBUG

    # Combine options
    ./start -f ~/my-bookmarks.json --console --log-level INFO

LOGGING:
    Log file location: /tmp/bunnify.log
    Log format: [timestamp] [level] [PID:pid] [module:function:line] message
    Log rotation: 10MB max size, 5 backup files

CONFIGURATION:
    Bookmarks file: ~/work/bunnify/bunnify.json
    Database: SQLite (db.sqlite3)
    Port: 8000

STOPPING THE SERVER:
    To stop the server, use one of these methods:
        1. kill <SERVER_PID>  (PID shown at startup)
        2. pkill -f "manage.py runserver"
        3. Check PID files: .bunnify.pid and .bunnify_watcher.pid

EOF
    exit 0
}

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Change to the script directory
cd "$SCRIPT_DIR"

# PID file location
PID_FILE="$SCRIPT_DIR/.bunnify.pid"
WATCHER_PID_FILE="$SCRIPT_DIR/.bunnify_watcher.pid"

# Default log settings
export BUNNIFY_LOG_LEVEL="WARNING"
export BUNNIFY_LOG_CONSOLE="false"

# Default bookmarks file
BOOKMARKS_FILE="${HOME}/work/bunnify/bunnify.json"

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            ;;
        -f|--bookmarks)
            if [ -z "$2" ]; then
                echo "Error: --bookmarks requires a file path"
                echo "Run './start --help' for more information"
                exit 1
            fi
            BOOKMARKS_FILE="$2"
            shift 2
            ;;
        --console)
            export BUNNIFY_LOG_CONSOLE="true"
            shift
            ;;
        --log-level)
            if [ -z "$2" ]; then
                echo "Error: --log-level requires a value"
                echo "Valid levels: DEBUG, INFO, WARNING, ERROR, CRITICAL"
                echo "Run './start --help' for more information"
                exit 1
            fi
            export BUNNIFY_LOG_LEVEL="$2"
            shift 2
            ;;
        *)
            echo "Error: Unknown option: $1"
            echo "Run './start --help' for usage information"
            exit 1
            ;;
    esac
done

# Function to check if process is running
is_running() {
    local pid=$1
    if [ -z "$pid" ]; then
        return 1
    fi
    if ps -p "$pid" > /dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# Function to check if port 8000 is in use
is_port_in_use() {
    lsof -ti:8000 > /dev/null 2>&1
}
# Function to check if process is Bunnify
is_bunnify_process() {
    local pid=$1
    if [ -z "$pid" ]; then
        return 1
    fi
    # Check if the process command line contains 'manage.py' and is in our directory
    ps -p "$pid" -o command= 2>/dev/null | grep -q "manage.py"
}

# Function to stop existing server
stop_server() {
    if [ -f "$PID_FILE" ]; then
        local server_pid=$(cat "$PID_FILE")
        if is_running "$server_pid"; then
            echo "üõë Stopping existing server (PID: $server_pid)..."
            kill "$server_pid" 2>/dev/null
            sleep 2
            if is_running "$server_pid"; then
                kill -9 "$server_pid" 2>/dev/null
            fi
        fi
        rm -f "$PID_FILE"
    fi
    
    if [ -f "$WATCHER_PID_FILE" ]; then
        local watcher_pid=$(cat "$WATCHER_PID_FILE")
        if is_running "$watcher_pid"; then
            echo "üõë Stopping file watcher (PID: $watcher_pid)..."
            kill "$watcher_pid" 2>/dev/null
        fi
        rm -f "$WATCHER_PID_FILE"
    fi
    
    # Check if port is still in use
    if is_port_in_use; then
        local port_pid=$(lsof -ti:8000 2>/dev/null | head -1)
        if [ -n "$port_pid" ]; then
            local proc_cmd=$(ps -p "$port_pid" -o command= 2>/dev/null)
            
            # Check if it's a Bunnify process
            if is_bunnify_process "$port_pid"; then
                echo "üõë Port 8000 still in use by Bunnify process (PID: $port_pid), killing..."
                kill -9 "$port_pid" 2>/dev/null
                sleep 1
            else
                echo "‚ö†Ô∏è  WARNING: Port 8000 is in use by a non-Bunnify process!"
                echo "   PID: $port_pid"
                echo "   Command: $proc_cmd"
                echo ""
                echo -n "Kill this process and continue? (y/N): "
                read -r response
                if [[ "$response" =~ ^[Yy]$ ]]; then
                    echo "üõë Killing process $port_pid..."
                    kill -9 "$port_pid" 2>/dev/null
                    sleep 1
                else
                    echo "‚ùå Aborted. Please free port 8000 manually and try again."
                    exit 1
                fi
            fi
        fi
    fi
}

# Check if server is already running
if [ -f "$PID_FILE" ]; then
    SERVER_PID=$(cat "$PID_FILE")
    if is_running "$SERVER_PID"; then
        echo "üê∞ Bunnify is already running (PID: $SERVER_PID)"
        echo "üîÑ Stopping and restarting..."
        stop_server
    else
        echo "üßπ Cleaning up stale PID file..."
        rm -f "$PID_FILE" "$WATCHER_PID_FILE"
    fi
elif is_port_in_use; then
    local port_pid=$(lsof -ti:8000 2>/dev/null | head -1)
    if is_bunnify_process "$port_pid"; then
        echo "‚ö†Ô∏è  Port 8000 is in use by another Bunnify process"
        echo "üîÑ Stopping existing process and starting fresh..."
        stop_server
    else
        local proc_cmd=$(ps -p "$port_pid" -o command= 2>/dev/null)
        echo "‚ö†Ô∏è  WARNING: Port 8000 is in use by a non-Bunnify process!"
        echo "   PID: $port_pid"
        echo "   Command: $proc_cmd"
        stop_server
    fi
fi

echo "üê∞ Starting Bunnify server..."
echo "Directory: $SCRIPT_DIR"
echo ""

# Expand tilde in bookmarks file path if present
BOOKMARKS_FILE="${BOOKMARKS_FILE/#\~/$HOME}"

# Check and load bookmarks
if [ -f "$BOOKMARKS_FILE" ]; then
    BOOKMARKS_ABS=$(cd "$(dirname "$BOOKMARKS_FILE")" && pwd)/$(basename "$BOOKMARKS_FILE")
    echo "üìñ Loading bookmarks from: $BOOKMARKS_ABS"
    
    # Load bookmarks initially (capture output to check for errors)
    LOAD_OUTPUT=$(./venv/bin/python3 manage.py load_bookmarks --file "$BOOKMARKS_FILE" 2>&1)
    LOAD_EXIT=$?
    
    if [ $LOAD_EXIT -eq 0 ]; then
        # Extract count from output (looks for "Successfully loaded X bookmarks")
        BOOKMARK_COUNT=$(echo "$LOAD_OUTPUT" | grep -o "loaded [0-9]\+ bookmarks" | grep -o "[0-9]\+")
        if [ -n "$BOOKMARK_COUNT" ]; then
            echo "‚úì Loaded $BOOKMARK_COUNT bookmarks"
        else
            echo "‚úì Bookmarks loaded"
        fi
    else
        echo "‚ö†Ô∏è  Warning: Error loading bookmarks"
    fi
    echo ""
else
    echo "‚ö†Ô∏è  Bookmarks file not found: $BOOKMARKS_FILE"
    echo "   Server will start but bookmarks may be empty"
    echo ""
fi

# Start the file watcher in the background (daemonized)
nohup ./venv/bin/python3 manage.py watch_bookmarks > /dev/null 2>&1 &
WATCHER_PID=$!
echo "$WATCHER_PID" > "$WATCHER_PID_FILE"

# Start the Django development server in the background (daemonized)
# Using [::]:8000 for dual-stack (IPv4 and IPv6) support
nohup ./venv/bin/python3 manage.py runserver [::]:8000 > /dev/null 2>&1 &
SERVER_PID=$!
echo "$SERVER_PID" > "$PID_FILE"

# Wait a moment for processes to start
sleep 1

# Verify both processes started successfully
if ! is_running "$SERVER_PID"; then
    echo "‚ùå Failed to start Django server"
    rm -f "$PID_FILE" "$WATCHER_PID_FILE"
    exit 1
fi

if ! is_running "$WATCHER_PID"; then
    echo "‚ö†Ô∏è  File watcher failed to start, but server is running"
    rm -f "$WATCHER_PID_FILE"
fi

# Display status
echo "‚úÖ Bunnify server started successfully!"
echo "   Server PID: $SERVER_PID"
echo "   Watcher PID: $WATCHER_PID"
echo "   URLs:"
echo "     - http://127.0.0.1:8000/ (IPv4)"
echo "     - http://[::1]:8000/ (IPv6)"
echo "     - http://localhost:8000/ (auto)"
echo "   Log file: /tmp/bunnify.log"
echo "   Log level: $BUNNIFY_LOG_LEVEL"
echo ""
echo "To stop the server, run: kill $SERVER_PID"
echo "Or use: pkill -f 'manage.py runserver'"
